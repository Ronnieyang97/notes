第八章 Traceroute程序
traceroute在大多数情况下从源端发往目的端的两份连续的IP数据具有相同的路由
它可以显示IP数据报从一台主机传到另一台主机经过的路由

记录路由一般是单向的选项，若发送端设置了该选项，那么接收端就不得不从收到的IP首部中提取出所有的信息并全部返回给发送端
IP首部中留给选项的空间有限，不能存放当前大多数的路径
因此使用traceroute，它使用ICMP报文和IP首部中的TTL字段（生存周期），TTL字段是由发送端初始设置一个8bit字段；
每个处理数据报的路由器都需要把TTL的值减一或减去数据报在路由器中停留的秒数（大多数时延都小于1，因此基本都减一）
TTL字段的目的是防止数据报在选路时无休止的在网络中流动，当路由器收到一份IP数据报时，如果其TTL字段是0或1，则路由器不转发该数据报，将其丢弃并给信源机发一份ICMP“超时”信息
traceroute的关键在于包含这份ICMP信息的IP报文的信源地址就是该路由器的IP地址

过程为：
traceroute程序发送一份TTL字段为1的IP数据报给目的主机，处理这份数据报的第一个路由器将TTL的值减一丢弃该数据报，并发回一份TTL值为2的数据报，就这样就可以得到第二个路由器的地址；
traceroute同时会发送一份UDP数据报给目的主机，不过他选择一个不可能的值作为UDP端口，因此当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误的ICMP报文，traceroute藉此判断什么时候结束

IP路由是动态的，例如（win10）tracert google.com两次的结果的中间部分的路由一般都是不一样的

########################################################################################################################################################################
8.1 当IP将接收到的TTL字段减一，发现它为0时，将会发什么事情？
输入的TTL为0时，会做减一操作然后测试会把TTL的值设置为255，并且让数据继续传输。

8.2 traceroute程序是如何计算RTT的？将这种计算RTT的方法与ping相比较
traceroute在UDP数据报的数据部分存储了12个字节，其中包含了数据报发送的时间，然而ICMP只返回了出错的IP数据报的头八个字节，实际上这八个字节时UDP的首部因此ICMP的差错报文并没有返回traceroute存储的时间值。traceroute保存了他发送发送分组的时间，当收到一个ICMP应答时，取出当时的时间，把两个值相减就可以得出RTT
而ping在输出的ICMP回显请求中储存了时间，会被服务器回显，即使分组返回时失序，ping也能打印出正确的RTT

8.3 假设源主机和目的主机之间有三个路由器，（R1, R2, R3），中间的路由器R2在进入TTL字段为1时，将TTL字段减一，但却错误的将该数据报发送往下一个路由器，会发生什么结果？运行traceroute时会看到什么样的现象？
第一行输出正确，并且标识了R1
下一个探测分组启动时，将TTL置为2，并且这个值被R1减1，当R2收到这个分组时，把TTL从1减为0，但是错误的将它传递给了R3。
R3看见进入的TTL是0就将超时的分组发送回来，这就意味着第2行输出标识了R3，而不是R2，因此第三行输出正确的标识了R3。
这个错误所表现出来的线索就是两个连续的输出标识了同一个路由器

8.4 同样，假设源主机和目的主机之间有三个路由器，由于目的主机上存在错误，因此他总是将进入TTL值作为外出ICMP报文的TTL值，这会产生什么结果，会产生什么现象。
在这种情况下，TTL为1标识了R1，TTL为2标识了R2，TTL为3标识了R3，但是当TTL为4时，UDP数据报到达了目的地，其输入的TTL为1.ICMP端口不可达报文生成了，但它的TTL是1（错误的从进入的TTL复制而来），这个ICMP报文到了R3，在那里TTL被减一，报文被丢弃，没有生成一个ICMP超时报文，因为被丢弃的数据报是一个ICMP差错报文（端口不可达）
最后对应于TTL为7的探测分组的端口不可达报文被送回了原地，到达时他的TTL为1.
TTL为1，2，3行正确的标识了R1,R2,R3，接下来的三行每个都包含三个超时，再接下来的TTL为7的行标识了目的地

8.5 在sun和netb之间的SLIP链路上运行tcpdump程序，如果指定-v选项，就可以看到返回ICMP报文的TTL值，这样就可以看到进入netb,butch,gabby,enss142.UT.westnet.net的TTL值分别为255，253，252，249.这是否为判断是否存在丢失路由提供了额外的信息？
它表明这些路由器都将一个ICMP报文的输出TTL设置为255，这是共同的，从netb输入的255的TTL值是我们想要的，而从butch输入的253的TTL值表明在butch和netb之间可能有一个未被察觉的路由器。否则这个点上应该看到一个TTL值为254的输入报文。这些表明这些未察觉的路由器没有正确的处理向外输出的UDP数据报，但他们都对返回的ICMP报文正确的进行了减一的操作

8.7 比较ping和traceroute程序在处理同一台主机上客户的多个实例的不同点
ping的客户端把ICMP回显请求报文的标识符字段设置成他的进程ID，ICMP回显应答报文包含同样值的标识符字段，每个客户都要查看这个返回的标识符字段并且只处理那些他发送过的报文
traceroute客户将他的UDP源端口号设置为他的进程ID和32678的逻辑或，因为返回的ICMP报文总是包含产生错误的IP数据报的前八个字节，这八个字节包括了完整的UDP首部，所以这个源端口号在ICMP差错报文中被返回

8.8 比较ping和traceroute程序在计算往返时间上的不同点
ping客户将ICMP回显请求报文的可选数据部分设置为分组发送的时间，这个可选的数据必须在ICMP回显应答中返回，这样使得即使分组返回时失序，客户也能计算出精确的回环时间
traceroute客户不能这样操作，因为在ICMP差错报文中返回的只是UDP首部，没有UDP数据，因此traceroute必须记住它发送请求的时间，等待应答，然后计算两者的时间差
此处显示了ping和traceroute的另一个不同点：ping每秒发送一个分组，而不管是都收到应答，traceroute发送一个请求，然后在发送下一个请求前等待一个应答或者超时
